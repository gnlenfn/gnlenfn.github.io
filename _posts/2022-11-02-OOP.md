---
title: "객체 지향과 스프링"
excerpt: ""

categories:
  - "Web"
tags:
  - ["Spring", "OOP"]

date_created: 2022-11-02T23:32:22+09:00
last_modified_at: 2022-11-02T23:32:22+09:00
toc: true
toc_sticky: true
---

# 객체 지향과 스프링

### 객체 지향 프로그래밍

-   추상화, 캡슐화, 상속, 다형성 이런 특징을 가진 프로그래밍의 패러다임
-   자바 웹 프레임워크인 스프링은 객체 지향 언어인 자바를 사용하는 만큼 그 특성을 잘 품고있음
-   네 가지 특징 중 가장 주목해야할 점은 바로 **다형성**
    -   다형성을 이용하기 위해서는 구현부와 역할부의 분리가 필요
    -   클라이언트는 해당 코드가 어떤 역할을 하는지 알 필요가 전혀 없고 그저 실행만 시키면 된다
    -   따라서 내부 구조가 어떻게 바뀌든 해당 코드는 변함없이 실행될 수 있게 된다 → 클라이언트의 코드를 변경하지 않고도 서버에서 기능을 유연하게 변경할 수 있다

### 다형성

다형성을 통해 객체 지향 언어는 같은 모양의 코드가 서로 다른 동작을 하도록 만들어준다. 자바에서 다형성을 녹여내는 방법으로는 오버라이딩과 오버로딩이 있다. 이것을 우리 주변의 모습에 비유했을 때 100%로 일치하도록 설명하는 것은 힘들다. 비슷하게나마 비유해 보자면, 우리가 텍스트 에디터에서 wasd를 누르는 것과 FPS 게임을 하면서 wasd를 누르는 것은 키보드를 누른다는 같은 행위를 하고 있지만 전혀 다른 결과를 보여주게 될 것이다.

오버로딩은 메서드의 파라미터가 달라지면 다른 메서드로 동작하게 되고, 오버라이딩은 상위 클래스의 메서드를 재정의하여 하위 클래스에서 사용하는 것을 말한다. 따라서 오버라이딩은 상위 클래스와 메서드 이름, 파라미터, 리턴타입이 모두 동일하지만 오버로딩은 메서드 이름만 같고 파라미터의 수나 타입은 다르다. 리턴 타입의 경우 상관없다.

스프링에서는 다형성을 이용해 다양한 응답이 가능하도록 구현하며 설계 시 역할에 해당하는 인터페이스를 먼저 작성한 뒤 그 역할을 수행하는 구현 객체를 작성할 때 인터페이스를 상속받는다. 그리고 필요할 때 원하는 구현 객체가 실행될 수 있도록 준비하는 것이다.

### 좋은 객체 지향 설계 원칙 (SOLID)

1.  **Single Responsibility Principle (SRP)**
    
    -   하나의 클래스는 하나의 책임만 가진다
    -   ‘책임’ 이라는 말이 모호하지만 코드 변경에 따른 파급효과라고 생각하자 파급 효과가 적을 수록 단일 책임 원칙을 잘 따른 것
2.  **Open-Closed Principle (OCP)**
    
    -   확장에는 열려있으나 변경에는 닫혀있다
    -   기능을 확장하려면 코드 변경이 있어야하는데 이게 무슨말인가!?
    -   다형성이라는 특징을 이용해 역할부와 구현부를 분리하더라도 직접 구현 클래스를 대입한다면 새로운 기능을 위해 코드 변경이 필요하다 → 다형성 만으로는 SOLID 원칙을 충족시킬 수 없음
3.  **Liskov Substitution Principle (LSP)**
    
    -   상속을 받은 자식 객체는 부모 객체의 메소드를 정확하게 수행할 수 있어야 한다.
    -   상속을 받으면 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야함
4.  **Interface Segregation Principle (ISP)**
    
    -   클라이언트가 자신이 사용하지 않는 메서드에 의존하지 않아야 한다
    -   큰 덩어리의 인터페이스를 구체적이고 작은 단위로 분리시켜야한다는 원칙
    
    ```java
    public interface Car {
    	void driving(DirectionType direction);
    	void fix(FixType type);
    }
    
    public interface Car {
    	void go();
    	void left();
    	void stop();
    	void right();
    
    	void fixHandle();
    	void fixEngine();
    }
    ```
    
    위의 Car에는 `driving` 이라는 운전 전체를 아우르는 인터페이스가 있는데, 만약 직진만 하는 개체가 있다면 좌우 혹은 뒤로 가는 것은 필요 없다. 따라서 아래의 Car처럼 좀 더 작고 구체적인 인터페이스로 분리하여 클라이언트가 필요로하는 메서드만 의존할 수 있도록 한다.
    
    1.  **Dependency Inversion Principle (DIP)**
        -   구현부가 아닌 역할부에 의존해야 한다
        -   의존 관계 성립 시 구현 클래스가 아닌 인터페이스에 의존해야한다

이 다섯 가지 원칙 중 스프링이 집중적으로 실현하고자 하는 부분은 OCP와 DIP라는 생각이 든다. 이 두 원칙을 충족하면서 다형성도 만족할 수 있도록 스프링이 기능 지원을 하고있기 때문이다. 이것을 위해 스프링은 DI, IoC 등 을 지원한다.

가장 중요한 부분은 스프링이 만들어진 이유가 자바의 객체 지향에 걸맞는 개발을 하기 위함이고 객체 지향 언어의 가장 큰 장점인 유연성과 확장성을 살리기 위해 만들어졌다는 것이다. 아직 말로만 들어서는 와닿지 않는 부분이 있었지만 코드를 직접 작성하다보니 객체 지향을 추구하려는 이유와 대규모 애플리케이션 개발에서 스프링이 강점을 가지는 이유가 조금은 느껴졌다. 다음에 이어질 포스팅에서 코드와 함께 그 내용을 정리해보겠다.